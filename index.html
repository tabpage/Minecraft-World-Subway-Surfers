<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minecraft world subway surfers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #111; 
            font-family: 'Segoe UI', sans-serif; 
            touch-action: none; /* ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤‡ßá ‡¶°‡¶ø‡¶´‡¶≤‡ßç‡¶ü ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶≤ ‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø */
        }
        #ui {
            position: absolute;
            top: env(safe-area-inset-top, 20px);
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 5;
        }
        #score { font-size: 2rem; font-weight: 900; margin-bottom: 0; }
        #high-score { font-size: 0.9rem; opacity: 0.8; margin-top: -5px; }
        #coins-ui { font-size: 1.2rem; color: #ffd700; font-weight: bold; }
        
        #powerup-ui {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 5;
            width: 90%;
            justify-content: center;
        }
        .power-bar {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: none;
            border: 1px solid rgba(255,255,255,0.3);
            white-space: nowrap;
        }

        /* ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ ‡¶¨‡¶æ‡¶ü‡¶® */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 6;
        }
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.5rem;
            border: 2px solid rgba(255,255,255,0.4);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            display: none;
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 20px;
            border: 2px solid #ff4757;
            z-index: 100;
            width: 80%;
            max-width: 400px;
        }
        button {
            padding: 12px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            background: #ff4757;
            border: none;
            color: white;
            border-radius: 50px;
            margin-top: 20px;
            transition: 0.2s;
        }
        #loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #111; color: white;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 1000;
        }
        
        @media (min-width: 768px) {
            #mobile-controls { display: none; } /* ‡¶™‡¶ø‡¶∏‡¶ø‡¶§‡ßá ‡¶¨‡¶æ‡¶ü‡¶® ‡¶π‡¶æ‡¶á‡¶° ‡¶•‡¶æ‡¶ï‡¶¨‡ßá */
            #score { font-size: 3rem; }
        }
    </style>
</head>
<body>

<div id="loading">
    <h1>Minecraft World Subway Surfers</h1>
    <p>Loading Mobile Assets...</p>
</div>

<div id="ui">
    <div id="score">0m</div>
    <div id="high-score">Best: 0m</div>
    <div id="coins-ui">Coins: 0</div>
</div>

<div id="powerup-ui">
    <div id="magnet-bar" class="power-bar">üß≤ <span id="mag-timer">0</span>s</div>
    <div id="board-bar" class="power-bar">üõπ ACTIVE</div>
</div>

<!-- ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶≠‡¶ø‡¶ú‡ßç‡¶Ø‡ßÅ‡ßü‡¶æ‡¶≤ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ -->
<div id="mobile-controls">
    <div class="control-btn" id="btn-left">‚Üê</div>
    <div class="control-btn" id="btn-jump">‚Üë</div>
    <div class="control-btn" id="btn-right">‚Üí</div>
</div>

<div id="msg">
    <h1>CRASHED!</h1>
    <p id="final-stats"></p>
    <button onclick="resetGame()">Try Again</button>
</div>

<script>
/**
 * STATE & CONFIG
 */
let scene, camera, renderer, clock;
let player, playerBox;
let lanes = [-5, 0, 5];
let currentLane = 1;
let isJumping = false, isRolling = false, gameActive = false;
let playerYVelocity = 0;

let hasMagnet = false, magnetTime = 0;
let hasBoard = false;

let score = 0, coinCount = 0, currentSpeed = 0.6;
let highScore = localStorage.getItem('runner_highscore') || 0;
const MAX_SPEED = 2.2;

let trackSegments = [], obstacles = [], coins = [], powerups = [];
const obstaclePool = [], coinPool = [], powerupPool = [];

let streetTex;
let particleGroup = new THREE.Group();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
    scene.add(particleGroup);

    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 8, 14);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // ‡¶™‡¶æ‡¶∞‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶∏ ‡¶Ö‡¶™‡ßç‡¶ü‡¶ø‡¶Æ‡¶æ‡¶á‡¶ú‡ßá‡¶∂‡¶®
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.7);
    scene.add(hemiLight);

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(20, 50, 20);
    sun.castShadow = true;
    scene.add(sun);

    clock = new THREE.Clock();
    document.getElementById('high-score').innerText = `Best: ${Math.floor(highScore)}m`;

    generateTextures();
    loadModels();
    createTrack();
    setupInputs();

    window.addEventListener('resize', onWindowResize);
}

function generateTextures() {
    const c1 = document.createElement('canvas');
    c1.width = 512; c1.height = 512;
    const ctx1 = c1.getContext('2d');
    ctx1.fillStyle = '#333'; ctx1.fillRect(0, 0, 512, 512);
    ctx1.fillStyle = '#ffd700'; ctx1.fillRect(160, 0, 8, 512); ctx1.fillRect(340, 0, 8, 512);
    streetTex = new THREE.CanvasTexture(c1); streetTex.wrapS = streetTex.wrapT = THREE.RepeatWrapping;
}

function loadModels() {
    const playerGroup = new THREE.Group();
    const body = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 3.2, 1.2), 
        new THREE.MeshStandardMaterial({ color: 0x3498db })
    );
    body.position.y = 1.6;
    body.castShadow = true;
    playerGroup.add(body);

    const board = new THREE.Mesh(
        new THREE.BoxGeometry(2.2, 0.3, 3.5),
        new THREE.MeshStandardMaterial({ color: 0x2ecc71 })
    );
    board.position.y = -0.1;
    board.name = "hoverboard";
    board.visible = false;
    playerGroup.add(board);

    player = playerGroup;
    scene.add(player);
    playerBox = new THREE.Box3();

    const coinGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.2, 12);
    window.coinModel = new THREE.Mesh(coinGeo, new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 }));
    window.coinModel.rotation.x = Math.PI / 2;

    setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
        gameActive = true;
        animate();
    }, 1500);
}

function createTrack() {
    const groundGeo = new THREE.PlaneGeometry(24, 50);
    const groundMat = new THREE.MeshStandardMaterial({ map: streetTex });
    for (let i = 0; i < 6; i++) {
        const seg = new THREE.Mesh(groundGeo, groundMat);
        seg.rotation.x = -Math.PI / 2;
        seg.position.z = -i * 50;
        scene.add(seg);
        trackSegments.push(seg);
    }
}

function spawnEntities() {
    if (!gameActive || Math.random() > 0.05) return;
    const laneIdx = Math.floor(Math.random() * 3);
    const rand = Math.random();

    if (rand < 0.6) {
        const h = 4.5;
        let obs = obstaclePool.length > 0 ? obstaclePool.pop() : new THREE.Mesh(new THREE.BoxGeometry(4.2, h, 8), new THREE.MeshStandardMaterial({ color: 0x222222 }));
        obs.userData.h = h;
        obs.position.set(lanes[laneIdx], h/2, -200);
        scene.add(obs);
        obstacles.push(obs);
    } else if (rand < 0.9) {
        let coin = coinPool.length > 0 ? coinPool.pop() : window.coinModel.clone();
        coin.position.set(lanes[laneIdx], 2.5, -200);
        scene.add(coin);
        coins.push(coin);
    } else {
        const type = Math.random() > 0.5 ? 'magnet' : 'board';
        const color = type === 'magnet' ? 0x00a8ff : 0x2ecc71;
        let p = powerupPool.length > 0 ? powerupPool.pop() : new THREE.Mesh(new THREE.OctahedronGeometry(1.2), new THREE.MeshStandardMaterial());
        p.material.color.set(color);
        p.userData.type = type;
        p.position.set(lanes[laneIdx], 3, -200);
        scene.add(p);
        powerups.push(p);
    }
}

function updatePhysics(delta) {
    const frameSpeed = currentSpeed * 60 * delta;
    playerBox.setFromObject(player);
    
    if (hasMagnet) {
        magnetTime -= delta;
        document.getElementById('mag-timer').innerText = Math.ceil(magnetTime);
        if (magnetTime <= 0) {
            hasMagnet = false;
            document.getElementById('magnet-bar').style.display = 'none';
        }
    }

    player.getObjectByName("hoverboard").visible = hasBoard;

    let groundY = 0;
    let onTop = false;

    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.position.z += frameSpeed;
        
        const isAbove = player.position.y >= obs.userData.h - 0.5;
        const isWithinX = Math.abs(player.position.x - obs.position.x) < 2;
        const isWithinZ = Math.abs(player.position.z - obs.position.z) < 5;

        if (isWithinX && isWithinZ) {
            if (isAbove) {
                onTop = true; groundY = obs.userData.h;
                if (playerYVelocity < 0) { player.position.y = groundY; playerYVelocity = 0; isJumping = false; }
            } else {
                if (hasBoard) {
                    hasBoard = false;
                    document.getElementById('board-bar').style.display = 'none';
                    createBurst(player.position, 0x2ecc71);
                    scene.remove(obs); obstacles.splice(i, 1);
                } else {
                    gameOver(); return;
                }
            }
        }
        if (obs.position.z > 50) { scene.remove(obs); obstacles.splice(i, 1); obstaclePool.push(obs); }
    }

    for (let i = coins.length - 1; i >= 0; i--) {
        const coin = coins[i];
        coin.position.z += frameSpeed;
        if (hasMagnet && coin.position.z > -80) {
            coin.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 1, player.position.z), 0.15);
        }
        if (playerBox.intersectsBox(new THREE.Box3().setFromObject(coin))) {
            coinCount++;
            document.getElementById('coins-ui').innerText = "Coins: " + coinCount;
            createBurst(coin.position, 0xffd700);
            scene.remove(coin); coins.splice(i, 1); coinPool.push(coin);
        } else if (coin.position.z > 50) {
            scene.remove(coin); coins.splice(i, 1); coinPool.push(coin);
        }
    }

    for (let i = powerups.length - 1; i >= 0; i--) {
        const p = powerups[i];
        p.position.z += frameSpeed;
        p.rotation.y += 0.05;
        if (playerBox.intersectsBox(new THREE.Box3().setFromObject(p))) {
            if (p.userData.type === 'magnet') {
                hasMagnet = true; magnetTime = 10;
                document.getElementById('magnet-bar').style.display = 'block';
            } else {
                hasBoard = true;
                document.getElementById('board-bar').style.display = 'block';
            }
            createBurst(p.position, p.material.color.getHex());
            scene.remove(p); powerups.splice(i, 1); powerupPool.push(p);
        } else if (p.position.z > 50) {
            scene.remove(p); powerups.splice(i, 1); powerupPool.push(p);
        }
    }

    if (player.position.y > groundY || playerYVelocity > 0) {
        playerYVelocity -= 0.6;
        player.position.y += playerYVelocity * delta * 5;
    }
    if (player.position.y <= 0) { player.position.y = 0; playerYVelocity = 0; isJumping = false; }
}

function createBurst(pos, color) {
    for (let i = 0; i < 6; i++) {
        const p = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshBasicMaterial({ color }));
        p.position.copy(pos);
        particleGroup.add(p);
        gsap.to(p.position, { 
            x:p.position.x+(Math.random()-0.5)*6, 
            y:p.position.y+Math.random()*6, 
            z:p.position.z-4, 
            duration: 0.5, 
            onComplete: () => particleGroup.remove(p) 
        });
    }
}

function animate() {
    if (!gameActive) return;
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    
    trackSegments.forEach(seg => {
        seg.position.z += currentSpeed;
        if (seg.position.z > 50) seg.position.z -= 6 * 50;
    });

    updatePhysics(delta);
    spawnEntities();
    
    score += currentSpeed * 0.2;
    document.getElementById('score').innerText = Math.floor(score) + "m";
    if (currentSpeed < MAX_SPEED) currentSpeed += 0.00015;

    camera.position.x = THREE.MathUtils.lerp(camera.position.x, player.position.x * 0.3, 0.05);
    camera.lookAt(player.position.x * 0.1, 4, -10);
    renderer.render(scene, camera);
}

function moveLane(dir) {
    if (!gameActive) return;
    let next = currentLane + dir;
    if (next >= 0 && next <= 2) {
        currentLane = next;
        gsap.to(player.position, { x: lanes[currentLane], duration: 0.25, ease: "power2.out" });
    }
}

function jump() {
    if (isJumping || !gameActive) return;
    isJumping = true; playerYVelocity = 18;
}

function roll() {
    if (isRolling || !gameActive) return;
    isRolling = true;
    gsap.to(player.scale, { y: 0.4, duration: 0.25, yoyo: true, repeat: 1, onComplete: () => {
        isRolling = false;
        player.scale.y = 1;
    }});
}

function setupInputs() {
    // Keyboard
    window.addEventListener('keydown', e => {
        if (e.key === "ArrowLeft") moveLane(-1);
        if (e.key === "ArrowRight") moveLane(1);
        if (e.key === "ArrowUp" || e.key === " ") jump();
        if (e.key === "ArrowDown") roll();
    });

    // Touch Controls (Buttons)
    document.getElementById('btn-left').addEventListener('touchstart', (e) => { e.preventDefault(); moveLane(-1); });
    document.getElementById('btn-right').addEventListener('touchstart', (e) => { e.preventDefault(); moveLane(1); });
    document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); jump(); });

    // Swipe Gestures
    let touchStartX = 0;
    let touchStartY = 0;
    window.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, false);

    window.addEventListener('touchend', e => {
        let touchEndX = e.changedTouches[0].screenX;
        let touchEndY = e.changedTouches[0].screenY;
        handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
    }, false);
}

function handleSwipe(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    if (Math.max(absDx, absDy) > 30) { // ‡¶Æ‡¶∞‡¶æ ‡¶∏‡ßã‡ßü‡¶æ‡¶á‡¶™ ‡¶´‡¶ø‡¶≤‡ßç‡¶ü‡¶æ‡¶∞
        if (absDx > absDy) {
            if (dx > 0) moveLane(1); else moveLane(-1);
        } else {
            if (dy < 0) jump(); else roll();
        }
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function gameOver() {
    gameActive = false;
    if (score > highScore) localStorage.setItem('runner_highscore', score);
    document.getElementById('final-stats').innerText = `Distance: ${Math.floor(score)}m | Coins: ${coinCount}`;
    document.getElementById('msg').style.display = 'block';
}

function resetGame() { location.reload(); }

init();
</script>
</body>
</html>

